#-*-coding:utf-8-*-
"""
    声音信号压缩 加噪以及降噪
    高斯白噪声 时域Kalman滤波
"""

import librosa as lr
import numpy as np
import matplotlib.pyplot as plt
from librosa.core import lpc

"""
    想法是：
        1. 输入一段音频，压缩（采样率8000Hz，尝试一下，原来的采样率为22KHz）加噪（零均值白噪声）
        2. 分帧操作，为了简便，两帧没有重合部分（帧移为1）
        3. 对每一段使用Kalman滤波，模型为AR模型驱动的状态转移方程以及一个定常的观测方程，初始协方差可能需要调参，
            协方差矩阵可能也不是一个对角阵，任意两个采样点之间可能不是独立的
        @todo
        4. 迭代过程中，状态转移的噪声协方差R不是一直固定的（一开始可以建模成完全固定的情况），噪声本身的方差是一定的（高斯白噪声过程决定）
            但是这个方差我们是不知道的，我们需要对其进行估计。LPC由于估计的是系统的最优参数（最小二乘的方法），那么必然会存在误差。假设无噪声信号就是系统的输出，那么误差就是加入的零均值噪声
            那么误差的协方差就是LPC的协方差。由于librosa的lpc函数没有协方差输出，所以我们需要把库函数提出来自己加接口。但是不知道使用forward还是backward
            则此情况下R是自适应的
        5. 每次迭代按照 predict（先验：状态转移，使用Xhat(n-1)以及A(n-1) R(n-1)得到先验估计）+ correct（后验：使用当前观测得到观测误差计算Kalman增益）

    难点：
        1. Kalman分帧之后，由于有高阶马尔可夫性，边缘段应该怎么处理？可以舍弃前 k 个点？但我们要求语音信号除了开始部分之后全部需要连续
        2. 大概的想法是：分帧时，由于后验估计是公用的，下一帧可以以这个后验估计开始，这就做到了两帧之间的平滑，后验估计相当于一个滑动窗，在帧内，帧间进行滑动。
            （由于上一帧处理完毕时，后验估计是上一帧最后一个采样点~上一帧最后采样点——阶数处的点）
        3. 一次迭代肯定不够，一次Kalman滤波一帧所有采样点之后求一个线性预测系数，根据这个系数重新预测（可以收敛到弱噪声数据上）
"""
class KalmanAudio:
    def __init__(self):
        pass

    def loadCompressClip(self, path:str):
        pass

    def saveAudio(self, path:str):
        pass

    def filter(self):
        pass